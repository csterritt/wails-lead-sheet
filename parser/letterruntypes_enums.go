// Code generated by goenums. DO NOT EDIT.
// This file was generated by github.com/zarldev/goenums
// using the command:
// goenums letter-run-type.go

package parser

import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"strconv"
)

type LetterRunType struct {
	letterRunType
}

type letterruntypesContainer struct {
	WORDRUN      LetterRunType
	CHORDRUN     LetterRunType
	SEPARATORRUN LetterRunType
	UNKNOWNRUN   LetterRunType
}

var LetterRunTypes = letterruntypesContainer{
	WORDRUN: LetterRunType{
		letterRunType: WordRun,
	},
	CHORDRUN: LetterRunType{
		letterRunType: ChordRun,
	},
	SEPARATORRUN: LetterRunType{
		letterRunType: SeparatorRun,
	},
	UNKNOWNRUN: LetterRunType{
		letterRunType: UnknownRun,
	},
}

func (c letterruntypesContainer) All() []LetterRunType {
	return []LetterRunType{
		c.WORDRUN,
		c.CHORDRUN,
		c.SEPARATORRUN,
		c.UNKNOWNRUN,
	}
}

var invalidLetterRunType = LetterRunType{}

func ParseLetterRunType(a any) (LetterRunType, error) {
	res := invalidLetterRunType
	switch v := a.(type) {
	case LetterRunType:
		return v, nil
	case []byte:
		res = stringToLetterRunType(string(v))
	case string:
		res = stringToLetterRunType(v)
	case fmt.Stringer:
		res = stringToLetterRunType(v.String())
	case int:
		res = intToLetterRunType(v)
	case int64:
		res = intToLetterRunType(int(v))
	case int32:
		res = intToLetterRunType(int(v))
	}
	return res, nil
}

func stringToLetterRunType(s string) LetterRunType {
	switch s {
	case "WordRun":
		return LetterRunTypes.WORDRUN
	case "ChordRun":
		return LetterRunTypes.CHORDRUN
	case "SeparatorRun":
		return LetterRunTypes.SEPARATORRUN
	case "UnknownRun":
		return LetterRunTypes.UNKNOWNRUN
	}
	return invalidLetterRunType
}

func intToLetterRunType(i int) LetterRunType {
	if i < 0 || i >= len(LetterRunTypes.All()) {
		return invalidLetterRunType
	}
	return LetterRunTypes.All()[i]
}

func ExhaustiveLetterRunTypes(f func(LetterRunType)) {
	for _, p := range LetterRunTypes.All() {
		f(p)
	}
}

var validLetterRunTypes = map[LetterRunType]bool{
	LetterRunTypes.WORDRUN:      true,
	LetterRunTypes.CHORDRUN:     true,
	LetterRunTypes.SEPARATORRUN: true,
	LetterRunTypes.UNKNOWNRUN:   true,
}

func (p LetterRunType) IsValid() bool {
	return validLetterRunTypes[p]
}

func (p LetterRunType) MarshalJSON() ([]byte, error) {
	return []byte(`"` + p.String() + `"`), nil
}

func (p *LetterRunType) UnmarshalJSON(b []byte) error {
	b = bytes.Trim(bytes.Trim(b, `"`), ` `)
	newp, err := ParseLetterRunType(b)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func (p *LetterRunType) Scan(value any) error {
	newp, err := ParseLetterRunType(value)
	if err != nil {
		return err
	}
	*p = newp
	return nil
}

func (p LetterRunType) Value() (driver.Value, error) {
	return p.String(), nil
}

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the goenums command to generate them again.
	// Does not identify newly added constant values unless order changes
	var x [1]struct{}
	_ = x[WordRun-0]
	_ = x[ChordRun-1]
	_ = x[SeparatorRun-2]
	_ = x[UnknownRun-3]
}

const _letterruntypes_name = "WordRunChordRunSeparatorRunUnknownRun"

var _letterruntypes_index = [...]uint16{0, 7, 15, 27, 37}

func (i letterRunType) String() string {
	if i < 0 || i >= letterRunType(len(_letterruntypes_index)-1) {
		return "letterruntypes(" + (strconv.FormatInt(int64(i), 10) + ")")
	}
	return _letterruntypes_name[_letterruntypes_index[i]:_letterruntypes_index[i+1]]
}
